#!/usr/bin/env bash

# Sorry, everyone
if (( ${BASH_VERSION%%.*} < 4 )); then
  echo "This script requires Bash >= 4. On OSX, try: brew install bash"
  exit 1
fi

# Any error is fatal.
set -e
# set -x # uncomment for debugging.

OCAML_TARBALL=https://www.dropbox.com/s/p2g539wopa52mvj/ocaml-4.02.3-64bit.tar.bz2?dl=0
OPAM_TARBALL=https://www.dropbox.com/s/uhgpzgkplviy2mh/opam-4.02.3-64bit.tar.bz2?dl=0
FLEXDLL_URL=http://alain.frisch.fr/flexdll/flexdll-0.35-setup.exe
Z3_VERSION=4.5.0
Z3_NAME=z3-$Z3_VERSION-x64-win
Z3_URL=https://github.com/Z3Prover/z3/releases/download/z3-$Z3_VERSION/$Z3_NAME.zip

# The whole script makes the assumption that we're in the everest directory;
# this is a conservative method that ensures we switch to this directory first
# thing. Basically, this supports:
# - calling "everest" (in the PATH)
# - calling "./everest" (same directory)
# - calling "/path/to/everest"
# - calling "../path/to/everest"
# This bails for corner cases, e.g. "source everest" or "wget http://.../everest | bash"
cd_to_everest () {
  echo -n "# Switching to the everest directory"
  if [[ ${0##*/} != "everest" ]]; then
    echo -e "\nThis script must be called via ./everest"
    exit 1
  fi
  if [[ $0 != ${0#*/} ]]; then
    # Relative or absolute path (contains /)
    cd $(dirname $0)
  else
    # Called via the path
    cd $(dirname $(which $0))
  fi
  echo " ... now in $(pwd)"
  echo
}
cd_to_everest

# "Modularity": include other files (requires us to be in the right directory)
source lib.sh
source repositories.sh
source hashes.sh

write_z3_bashrc () {
  str="
    # This line automatically added by $0
    export PATH=$(pwd)/$Z3_NAME:\$PATH"
  eval "$str"
  echo "$str" >> ~/.bashrc
}

write_ocaml_bashrc () {
  str="
    # These lines automatically added by $0
    export PATH=/cygdrive/c/ocamlmgw64/bin/:\$PATH
    export PATH=\$HOME/.opam/system/bin:\$PATH
    export PATH=\$HOME/.opam/system/lib/stublibs:\$PATH
    export PATH=/cygdrive/c/Program\ Files\ \(x86\)/flexdll/:\$PATH
    export OCAMLFIND_CONF=$(cygpath -m ~/.opam/system/lib/findlib.conf)
    export OCAML_TOPLEVEL_PATH=$(cygpath -m ~/.opam/system/lib/toplevel/)"
  eval "$str"
  echo "$str" >> ~/.bashrc
}

write_cygwin_bashrc () {
  str="
    # These lines automatically added by $0
    export PATH=/usr/x86_64-w64-mingw32/sys-root/mingw/bin:\$PATH
    export CYGWIN='winsymlinks:native'"
  eval "$str"
  echo "$str" >> ~/.bashrc
}

write_fstar_kremlin_bashrc () {
  str="
    # These lines automatically added by $0
    export PATH=$(pwd)/FStar/bin:\$PATH
    export PATH=$(pwd)/kremlin:\$PATH"
  eval "$str"
  echo "$str" >> ~/.bashrc
}

do_check ()
{
  blue "Checking environment"

  # Basic utilities
  success_or "which" "please execute this script in a Unix environment"
  if is_osx; then
    success_or "greadlink" "please run \"brew install coreutils\""
  fi

  # Windows pre-requisites
  if is_windows; then
    # A list of known causes for failure
    if where.exe bash.exe | grep -v cygwin >/dev/null 2>&1; then
      red "ERROR: bash.exe has been found in a non-standard location!"
      echo "Please remove Bash for Windows and others (GNU for Windows, MSYS2, etc.)"
      red "Are you sure you want to continue? [Yn]"
      prompt_yes true "exit 1"
    fi
    echo "... no suspicious bash"
    if [[ $(uname -m) != "x86_64" ]]; then
      red "ERROR: not a 64-bit Cygwin"
      echo "We've experienced tons of issues with 32-bit Cygwin. Time to upgrade."
      exit 1
    fi
    echo "... 64-bit cygwin"
    if cygwin_has "ocaml" || cygwin_has "flexdll"; then
      red "ERROR: please remove the cygwin ocaml and/or flexdll packages"
      exit 1
    fi
    echo "... no suspicious cygwin packages"

    # The list of required cygwin packages
    for p in $(cat cygwin-packages); do
      if ! cygwin_has $p; then
        cygsetup="setup-x86_64.exe"
        found=false
        for s in $USERPROFILE/Desktop/$cygsetup $USERPROFILE/Downloads/$cygsetup ./$cygsetup; do
          if [ -x "$s" ]; then
            echo "Found $cygsetup"
            found=true
            cygsetup=$s
          fi
        done
        if ! $found; then
          magenta "Cygwin setup not found, downloading it"
          wget "https://cygwin.com/setup-x86_64.exe"
          cygsetup=./$cygsetup
        fi
        echo "Cygwin package $p is missing"
        if_yes "$cygsetup --no-desktop --no-shortcuts --no-startmenu --quiet-mode --packages=\$(cat cygwin-packages | tr '\n' ,)"
        magenta "Automatically customize ~/.bashrc with the x86_64-mingw32 path + native windows symlinks?"
        prompt_yes write_cygwin_bashrc true
      fi
    done
    # TODO modify ~/.bashrc here
    echo "... all $(cat cygwin-packages | wc -l) cygwin packages seem to be installed"
  fi

  # OCaml detection
  if ! command -v >/dev/null 2>&1 ocaml; then
    # Offer to install and sed-setup a crappy snapshot
    if is_windows; then
      magenta "No OCaml detected. Will fetch & install Jonathan's binaries."
      echo This will download and install a one-time OPAM snapshot\; this will \
        create c:/ocamlmgw64 and ~/.opam\; you will  need to refresh it \
        periodically via $0 update_opam. If you intend to do some serious \
        development, you\'re probably better off using \
        https://fdopen.github.io/opam-repository-mingw/. Proceed anyhow?
      prompt_yes true "exit 1"
      if [ -e ~/.opam ]; then
        red "ERROR: stale ~/.opam; aborting"
        exit 1
      fi
      if [ -e /cygdrive/c/ocamlmgw64 ]; then
        red "ERROR: stale /cygdrive/c/ocamlmgw64"
      fi
      (cd c:/ && wget -O - $OCAML_TARBALL | tar xjvf -)
      (cd ~ && wget -O - $OPAM_TARBALL | tar xjvf -)
      (cd ~/.opam/system/lib && find . -iname '*.cmxs' -exec chmod a+x {} \;)
      (cd ~/.opam/system/lib &&
        echo -e "destdir=\"$(cygpath -m $(pwd))\"\npath=\"$(cygpath -m $(pwd))\"" > findlib.conf.new &&
        tail -n +3 findlib.conf >> findlib.conf.new &&
        mv findlib.conf.new findlib.conf)
      if ! command -v flexlink >/dev/null 2>&1; then
        magenta "No flexdll found; downloading and running Alain's installer"
        magenta "You need to double-click on the install and click through!"
        wget -O flexdll.exe $FLEXDLL_URL && chmod 755 flexdll.exe && explorer flexdll.exe
      fi
      magenta "Automatically customize ~/.bashrc with the the magic variables you need?"
      prompt_yes write_ocaml_bashrc true
      exit 0

    else
      red "ERROR: no ocaml found in PATH"
      if is_osx; then
        echo "Hint: brew install ocaml opam"
      else
        echo "Please use your distribution's package management system to install ocaml and opam"
        echo "Note: on older Ubuntus, see https://launchpad.net/~avsm/+archive/ubuntu/ppa"
      fi
      exit 1
    fi

  else
    # OCaml; if this exits, set -e means this is a hard error
    ocaml -noinit -noprompt -stdin <<OCAML
      if Sys.ocaml_version < "4.02.2" then begin
        print_endline "ERROR: Everest needs OCaml >= 4.02.2";
        exit 1
      end
OCAML
    echo "... ocaml minimum version requirements met"
  fi

  # OCamlfind & extra packages. Required OPAM packages are stored in
  # [opam-packages] with one package name per line
  success_or "opam"
  success_or "ocamlfind"
  missing=false
  while read line; do
    ocamlfind_package=$(echo $line | cut -d " " -f 1)
    opam_package=$(echo $line | cut -d " " -f 2)
    if ! ocamlfind query $ocamlfind_package >/dev/null 2>&1; then
      red "ERROR: ocamlfind package $ocamlfind_package is not installed"
      missing=true
    fi
  done < opam-packages
  if $missing; then
    if_yes "opam install $(cat opam-packages | cut -d ' ' -f 2 | tr '\n' ' ')"
  fi
  echo "... all $(cat opam-packages | wc -l) ocamlfind packages found"

  # Test for the existence of fsc (windows) or fsharpc (other)
  if is_windows; then
    success_or "fsc"
  else
    success_or "fsharpc"
  fi

  if ! which z3 >/dev/null 2>&1 || [[ $(z3 --version | tr -d '\r\n') != "Z3 version $Z3_VERSION - 64 bit" ]]; then
    red "ERROR: the right version of z3 doesn't seem to be installed"
    if is_windows; then
      magenta "Download it from the internet? [Yn]"
      prompt_yes true "exit 1"
      wget $Z3_URL
      unzip $Z3_NAME
      find $Z3_NAME -iname '*.dll' -or -iname '*.exe' -exec chmod a+x {} \;
      magenta "Automatically customize ~/.bashrc with the z3 path?"
      prompt_yes write_z3_bashrc true
    else
      echo "Hint: brew install z3 (OSX), apt-get install z3 (other)"
      echo "Hint: most recent versions available at https://github.com/Z3Prover/z3/releases/tag/z3-$Z3_VERSION"
      exit 1
    fi
  fi
  echo "... correct z3 version detected"

  if ! command -v fstar.exe >/dev/null 2>&1 || ! command -v krml >/dev/null 2>&1; then
    magenta "I don't see any fstar.exe or krml in your path; add $(pwd)/FStar/bin and $(pwd)/kremlin to your PATH via ~/.bashrc?"
    prompt_yes write_fstar_kremlin_bashrc true
  fi
  echo "... fstar.exe and krml in PATH"
}

do_pull ()
{
  blue "Pulling; this implies git pull in every tracked project"
  warned=false
  for r in ${!repositories[@]}; do
    # Some sanity checks, and clone the repositories that aren't there already
    if [ ! -d $r ]; then
      if [ -e $r ]; then
        red "$r exists but is not a directory, aborting"
        exit 1
      fi
      if ! $warned; then
        echo Note: you\'re welcome to create symbolic links if you already have \
          cloned the repository elsewhere
        warned=true
      fi
      if_yes "git clone ${repositories[$r]} $r"
    fi

    # All sorts of git magic to try to figure out how to smartly checkout the
    # listed reference
    cd $r
    git fetch
    hash=${hashes[$r]}

    # Find the first remote branch that contains the desired commit
    branch=$(git branch -r --color=never --contains $hash | grep -v -- '->' | head -n 1 | cut -c 3-)

    if [[ $branch == "" ]]; then
      magenta "In $r, no know branch contains $hash! Seems like someone forgot to push a commit... trying anyhow"
      git checkout $hash

    else
      echo "In $r, $branch contains $hash"
      short=${branch#*/}
      echo "Trying to switch to branch $short"
      git checkout $short
      if [[ $(git rev-parse --abbrev-ref --symbolic-full-name @{u}) != $branch ]]; then
        magenta "Argh! $short is actually not tracking $branch... going for DETACHED HEAD"
        git checkout $hash
      elif ! git merge --ff $hash; then
        # Case where local branch has diverged from origin
        if_yes "git merge $hash"
      fi

    fi
    cd ..
  done
}

do_make ()
{
  blue "Rebuilding all projects"
  mkdir -p log
  echo
  blue "Rebuilding F*"
  make -C FStar/src/ocaml-output -j 15 | count "log/fstar"
  echo
  blue "Rebuilding miTLS"
  make -C mitls-fstar/src/tls -j 15 tls-gen | count "log/mitls-gen"
  echo
  blue "Rebuilding KreMLin"
  make -C kremlin -j 15 | count "log/kremlin"
}

do_snapshot ()
{
  blue "Recording a new snapshot"
  echo "declare -A hashes" > new-hashes.sh
  for r in ${!repositories[@]}; do
    cd $r
    head=$(git rev-parse HEAD)
    if [[ $(git branch -r --contains $head) == "" ]]; then
      red "WARNING: in repository $r, current revision $head has not been pushed!"
    fi
    cd ..
    echo "recording $r at revision $head"
    echo "hashes[$r]=$head" >> new-hashes.sh
  done
  mv new-hashes.sh hashes.sh
  cat <<MSG

New hashes have been recorded in hashes.sh. You can see the changes with git
diff.

If you intend to make this set of working revisions widely available, then you
must run commit and push.
MSG
}

print_usage ()
{
  cat <<HELP
OVERVIEW: $0, a high-level management script for Project Everest

USAGE: $0 COMMAND

COMMANDS:
  check     ensure that all the required programs are found in path, install
            them if needed; offer to customize ~/.bashrc with proper env
            variables

  pull      pull all projects and move them to the revisions specified by
            hashes.sh

  make      rebuild all projects

  snapshot  make the current state a new known set of working revisions; this
            writes into hashes.sh

  help      print the current message
HELP
}

# Parsing script arguments.
case "$1" in
  check)
    do_check
    ;;

  pull)
    do_pull
    ;;

  make)
    do_make
    ;;

  snapshot)
    do_snapshot
    ;;

  *)
    print_usage
    ;;
esac
