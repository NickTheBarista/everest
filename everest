#!/usr/bin/env bash

# Sorry, everyone
if (( ${BASH_VERSION%%.*} < 4 )); then
  echo "This script requires Bash >= 4. On OSX, try: brew install bash"
  exit 1
fi

# Any error is fatal.
set -e
# set -x # uncomment for debugging.

# "Modularity": include other files
source lib.sh
source repositories.sh
source hashes.sh

do_check ()
{
  echo "CHECKING ENVIRONMENT"

  # Basic utilities
  success_or "which" "please execute this script in a Unix environment"
  if is_osx; then
    success_or "greadlink" "please run \"brew install coreutils\""
  fi

  # OCaml
  success_or "ocaml"
  ocaml -noinit -noprompt -stdin <<OCAML
    if Sys.ocaml_version < "4.02.2" then begin
      print_endline "ERROR: Everest needs OCaml >= 4.02.2";
      exit 1
    end
OCAML

  # OCamlfind & extra packages. Required OPAM packages are stored in
  # [opam-packages] with one package name per line
  success_or "ocamlfind"
  for p in $(cat opam-packages); do
    if ! ocamlfind query $p >/dev/null 2>&1; then
      echo "ERROR: ocamlfind package $p is not installed"
      if_yes "opam install $p"
    fi
  done
  echo "... all ocamlfind packages found"

  # Test for the existence of fsc (windows) or fsharpc (other)
  if is_windows; then
    success_or "fsc"
  else
    success_or "fsharpc"
  fi

  # TODO: on Windows, check for all the quirks in my ocaml-installer wiki,
  # including broken OCaml setups, and download binaries for my (own copy) of
  # c:\ocamlmgw64 (which should not require any environment var tweak) and
  # ~/.opam.
}

do_env ()
{
  echo "Not implemented"
}

do_pull ()
{
  echo "PULLING; this implies git pull in every tracked project"
  warned=false
  for r in ${!repositories[@]}; do
    # Some sanity checks, and clone the repositories that aren't there already
    if [ ! -d $r ]; then
      if [ -f $r ]; then
        echo "$r exists but is not a directory, aborting"
        exit 1
      fi
      if ! $warned; then
        echo Note: you\'re welcome to create symbolic links if you already have \
          cloned the repository elsewhere
        warned=true
      fi
      if_yes "git clone ${repositories[$r]} $r"
    fi

    # All sorts of git magic to try to figure out how to smartly checkout the
    # listed reference
    cd $r
    git fetch
    hash=${hashes[$r]}

    # Find the first remote branch that contains the desired commit
    branch=$(git branch -r --color=never --contains $hash | grep -v -- '->' | head -n 1 | cut -c 3-)

    # Try to find a remote branch that contains this hash (there HAS to be one)
    if [[ $branch == "" ]]; then
      echo In $r, no know branch contains $hash! Seems like someone forgot to \
        push a commit... trying anyhow
      git checkout $hash

    else
      echo "In $r, $branch contains $hash"
      short=${branch#*/}
      echo "Trying to switch to branch $short"
      git checkout $short
      if [[ $(git rev-parse --abbrev-ref --symbolic-full-name @{u}) != $branch ]]; then
        echo "Argh! $short is actually not tracking $branch... going for DETACHED HEAD"
        git checkout $hash
      elif ! git merge --ff $hash; then
        # Case where local branch has diverged from origin
        if_yes "git merge $hash"
      fi

    fi
    cd ..
  done
}

do_make ()
{
  true
}

do_snapshot ()
{
  echo "SNAPSHOT"
  echo "declare -A hashes" > new-hashes.sh
  for r in ${!repositories[@]}; do
    cd $r
    head=$(git rev-parse HEAD)
    if [[ $(git branch -r --contains $head) == "" ]]; then
      echo "WARNING: in repository $r, current revision $head has not been pushed!"
    fi
    cd ..
    echo "recording $r at revision $head"
    echo "hashes[$r]=$head" >> new-hashes.sh
  done
  mv new-hashes.sh hashes.sh
  cat <<MSG

New hashes have been recorded in hashes.sh. You can see the changes with git
diff.

If you intend to make this set of working revisions widely available, then you
must run commit and push.
MSG
}

print_usage ()
{
  cat <<HELP
OVERVIEW: $0, a high-level management script for Project Everest

USAGE: $0 COMMAND

COMMANDS:
  check     ensure that all the required programs are found in path

  env       print a set of environment variables that you should put in your ~/.bashrc

  pull      update the known set of working revisions, then proceed to update the working
            trees one by one

  make      rebuild all projects

  snapshot  record the current status of all projects a new known set of working
            revisions

  help      print the current message
HELP
}

# Parsing script arguments.
case "$1" in
  check)
    do_check
    ;;

  env)
    do_env
    ;;

  pull)
    do_pull
    ;;

  make)
    do_make
    ;;

  snapshot)
    do_snapshot
    ;;

  *)
    print_usage
    exit 0
    ;;
esac
